import pandas as pd

class OrgNode:
    def __init__(self, name, email, emp_id, title):
        self.name    = name
        self.email   = email
        self.emp_id  = emp_id
        self.title   = title
        self.manager = None

    def set_manager(self, mgr_node):
        self.manager = mgr_node

    def get_chain_upwards(self):
        chain = [{
            "Name":         self.name,
            "Email":        self.email,
            "Employee ID":  self.emp_id,
            "Title":        self.title
        }]
        current = self.manager
        while current:
            chain.append({
                "Name":         current.name,
                "Email":        current.email,
                "Employee ID":  current.emp_id,
                "Title":        current.title
            })
            current = current.manager
        return chain

class OrgChartBuilder:
    def __init__(self,
                 hierarchy_file: str,
                 department_map_file: str,
                 input_employees_file: str):
        self.hierarchy_file       = hierarchy_file
        self.department_map_file  = department_map_file
        self.input_employees_file = input_employees_file

        self.nodes          = {}
        self.department_map = {}
        self.input_emails   = set()

    def load_input_emails(self):
        df = (pd.read_csv(self.input_employees_file)
              if self.input_employees_file.lower().endswith(".csv")
              else pd.read_excel(self.input_employees_file))
        if 'Email' not in df.columns:
            raise ValueError("Input file must contain an 'Email' column.")
        # Normalize to lowercase for comparison
        self.input_emails = set(df['Email']
                                 .dropna()
                                 .str.strip()
                                 .str.lower()
                                 .tolist())

    def build_department_map(self):
        df = pd.read_excel(self.department_map_file)
        for _, row in df.iterrows():
            key   = str(row['Name']).strip().lower()
            dept  = str(row['Department']).strip()
            self.department_map[key] = dept

    def build_graph(self):
        df = pd.read_excel(self.hierarchy_file)
        for _, row in df.iterrows():
            emp_email = row["Employee Email"]
            emp_id    = str(row["Employee ID"]).strip()
            emp_node  = self.nodes.get(emp_email) or OrgNode(
                name=row["Employee Name"],
                email=emp_email,
                emp_id=emp_id,
                title=row["Employee Title"]
            )
            self.nodes[emp_email] = emp_node

            mgr_email = row["Manager Email"]
            mgr_id    = (str(row["Manager ID"]).strip()
                         if pd.notnull(row["Manager ID"]) else "")
            if pd.notnull(mgr_email):
                mgr_node = self.nodes.get(mgr_email) or OrgNode(
                    name=row["Manager Name"],
                    email=mgr_email,
                    emp_id=mgr_id,
                    title=row["Manager Title"]
                )
                self.nodes[mgr_email] = mgr_node
                emp_node.set_manager(mgr_node)

    def resolve_multi_level_departments(self, chain):
        levels = []
        for person in reversed(chain):  # top-down
            key_name  = person["Name"].strip().lower()
            key_email = person["Email"].strip().lower()
            # match either by name or email in map
            if key_name in self.department_map:
                dept = self.department_map[key_name]
                if dept not in levels:
                    levels.append(dept)
            elif key_email in self.department_map:
                dept = self.department_map[key_email]
                if dept not in levels:
                    levels.append(dept)
        return levels

    def export_hierarchy_flat_view(self, output_file):
        records = []
        for node in self.nodes.values():
            # filter by base email
            if node.email.strip().lower() not in self.input_emails:
                continue

            chain = node.get_chain_upwards()

            # Start each row with Base Email
            row = {"Base Email": node.email}

            # Flatten the chain into Level 0, Level 1, â€¦
            for i, lvl in enumerate(chain):
                row[f"Level {i} Name"]       = lvl["Name"]
                row[f"Level {i} Email"]      = lvl["Email"]
                row[f"Level {i} Employee ID"] = lvl["Employee ID"]
                row[f"Level {i} Title"]      = lvl["Title"]

            # Add multi-level departments
            depts = self.resolve_multi_level_departments(chain)
            for j, dept in enumerate(depts, start=1):
                row[f"Department Level {j}"] = dept

            records.append(row)

        df_flat = pd.DataFrame(records)
        df_flat.to_excel(output_file, index=False)
        print(f"Exported filtered hierarchy to {output_file}")
        return df_flat

if __name__ == "__main__":
    builder = OrgChartBuilder(
        hierarchy_file="employee_manager_with_roles.xlsx",
        department_map_file="department_mapping.xlsx",
        input_employees_file="input_employees.xlsx"    # now uses Email
    )
    builder.load_input_emails()
    builder.build_department_map()
    builder.build_graph()
    builder.export_hierarchy_flat_view("filtered_flattened_hierarchy_by_email.xlsx")