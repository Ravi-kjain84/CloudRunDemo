    def calculate_all_phases(self) -> pd.DataFrame:
        results = []

        for jira_id, group in self.df.groupby('Jira_Id'):
            g = group.sort_values('Timestamp', ignore_index=True)
            
            # initialize zeroed durations
            durations = {phase: 0.0 for phase in self.phases}
            
            # make a list of rows so we can walk pairwise
            rows = list(g.itertuples(index=False))
            for prev, curr in zip(rows, rows[1:]):
                delta = (curr.Timestamp - prev.Timestamp).total_seconds() / 86400
                prev_status = prev.Change_Value.strip()
                curr_status = curr.Change_Value.strip()

                # assign this delta to the first matching phase
                for phase, (starts, ends) in self.phases.items():
                    if prev_status in starts and curr_status in ends:
                        durations[phase] += delta
                        break

            # build the output row
            row = {'Jira_Id': jira_id}
            for phase, days in durations.items():
                val = round(days, 2) if days > 0 else None
                row[f"{phase} (days)"] = val

            # raw span & totals
            raw = self._calculate_raw_total_time(g)
            tracked = sum(v for v in durations.values() if v > 0)
            row["Raw Total Time (days)"]   = raw
            row["Total Time (days)"]       = round(tracked, 2) if tracked else None
            row["Gap Time (days)"]         = (
                round(raw - tracked, 2)
                if raw is not None and tracked
                else None
            )

            results.append(row)

        return pd.DataFrame(results)